# Note: we're using a reusable workflow instead of a custom action to have a clean checkout on every run.
on:
  workflow_call:
    inputs:
      path: # submodule path in the source repository
        type: string
        required: true
      name: # Name used for a changelog entry
        type: string
        required: true
    secrets:
      api_token:
        required: true

jobs:
  cancel-previous-run:
    runs-on: ubuntu-latest
    steps:
      - name: Cancel Previous Runs
        uses: styfle/cancel-workflow-action@a40b8845c0683271d9f53dfcb887a7e181d3918b # Tag: 0.9.1
        with:
          access_token: ${{ github.token }}

  # What we need to accomplish:
  # * update the submodule to the latest tag
  # * create a PR
  # * update changelog (including the link to the just created PR)
  #
  # What we actually do is based on whether a PR exists already:
  # * YES it does:
  #    * make the update
  #    * update changelog (with the ID of an existing PR)
  #    * push to the PR
  # * NO it doesn't:
  #    * make the update
  #    * push to a new PR
  #    * update changelog (with the ID of the just created PR)
  #    * push to the PR
  # We do different approach on subsequent runs because otherwise we would spam users' mailboxes
  # with notifications about pushes to existing PRs. This way there is actually no push if not needed.
  update:
    runs-on: ubuntu-latest
    timeout-minutes: 30
    defaults:
      run:
        shell: pwsh
    steps:
      - uses: actions/checkout@v3
        with:
          ssh-key: ${{ secrets.api_token }}

      - run: git submodule update --init --no-fetch --single-branch '${{ inputs.path }}'

      - name: Check out the latest submodule version
        id: submodule
        working-directory: ${{ inputs.path }}
        run: |
          git fetch --tags
          $originalTag = $(git describe --tags)
          $latestTagCommit = $(git rev-list --tags --max-count=1)
          $latestTag = $(git describe --tags $latestTagCommit)
          $latestTagNice = ($latestTag -match "^[0-9]") ? "v$latestTag" : $latestTag
          $mainBranch = $(git remote show origin | Select-String "HEAD branch: (.*)").Matches[0].Groups[1].Value
          $url = $(git remote get-url origin) -replace '\.git$',''
          git checkout $latestTagCommit
          Write-Host '::echo::on'
          Write-Host "::set-output name=originalTag::$originalTag"
          Write-Host "::set-output name=latestTag::$latestTag"
          Write-Host "::set-output name=latestTagCommit::$latestTagCommit"
          Write-Host "::set-output name=latestTagNice::$latestTagNice"
          Write-Host "::set-output name=url::$url"
          Write-Host "::set-output name=mainBranch::$mainBranch"

      - name: Get the base repo info
        if: steps.submodule.outputs.latestTag != steps.submodule.outputs.originalTag
        id: root
        run: |
          $mainBranch = $(git remote show origin | Select-String "HEAD branch: (.*)").Matches[0].Groups[1].Value
          Write-Host '::echo::on'
          Write-Host "::set-output name=baseBranch::$mainBranch"
          Write-Host "::set-output name=prBranch::deps/${{ inputs.path }}/${{ steps.submodule.outputs.latestTag }}"

      - name: Fetch an existing PR
        if: steps.submodule.outputs.latestTag != steps.submodule.outputs.originalTag
        uses: octokit/request-action@971ad48f9c40ed001c41c2671b1e6e8e8165d5af
        id: existing-pr-request
        with:
          route: GET /repos/${{ github.repository }}/pulls?base={base}&head={head}
          head: '${{ github.repository }}:${{ steps.root.outputs.prBranch }}'
          base: '${{ steps.root.outputs.baseBranch }}'
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Parse the existing PR number
        if: steps.submodule.outputs.latestTag != steps.submodule.outputs.originalTag
        id: existing-pr
        run: |
          $data = @'
          ${{ steps.existing-pr-request.outputs.data }}
          '@

          $prCount = $($data | jq '. | length')

          if ($prCount -eq '0')
          {
              $number = ''
          }
          elseif ($prCount -eq '1')
          {
              $number = $($data | Select-String '"number": +([0-9]+)').Matches[0].Groups[1].Value
          }
          else
          {
              throw "Unexpected number of PRs matched: $prCount"
          }

          Write-Host '::echo::on'
          Write-Host "::set-output name=number::$number"

      # First we create a PR only if it doesn't exist. We will later overwrite the content with the same action.
      - name: Create a PR
        if: ${{ ( steps.submodule.outputs.latestTag != steps.submodule.outputs.originalTag ) && ( steps.existing-pr.outputs.number == '') }}
        uses: peter-evans/create-pull-request@f22a7da129c901513876a2380e2dae9f8e145330
        id: create-pr
        with:
          base: ${{ steps.root.outputs.baseBranch }}
          branch: ${{ steps.root.outputs.prBranch }}
          add-paths: '${{ inputs.path }}'
          author: 'GitHub <noreply@github.com>'
          title: 'chore(deps): update ${{ inputs.name }} to ${{ steps.submodule.outputs.latestTagNice }}'
          # draft: true

      - name: Verify we have a PR
        if: steps.submodule.outputs.latestTag != steps.submodule.outputs.originalTag
        id: pr
        run: |
          Write-Host '::echo::on'
          if ('${{ steps.create-pr.outputs.pull-request-number }}' -ne '')
          {
              Write-Host "::set-output name=number::${{ steps.create-pr.outputs.pull-request-number }}"
          }
          elseif ('${{ steps.existing-pr.outputs.number }}' -ne '')
          {
              Write-Host "::set-output name=number::${{ steps.existing-pr.outputs.number }}"
          }
          else
          {
              throw "PR hasn't been created"
          }

      # If we had to create a new PR, we must do a clean checkout & update the submodule again.
      # If we didn't do this, the new PR would only have a changelog...
      - name: 'After new PR: restore repo'
        if: ${{ ( steps.submodule.outputs.latestTag != steps.submodule.outputs.originalTag ) && ( steps.existing-pr.outputs.number == '') }}
        uses: actions/checkout@v3
        with:
          ssh-key: ${{ secrets.api_token }}

      - name: 'After new PR: checkout submodule'
        if: ${{ ( steps.submodule.outputs.latestTag != steps.submodule.outputs.originalTag ) && ( steps.existing-pr.outputs.number == '') }}
        run: |
          git submodule update --init --no-fetch --single-branch '${{ inputs.path }}'
          cd '${{ inputs.path }}'
          git checkout '${{ steps.submodule.outputs.latestTagCommit }}'

      - name: Update Changelog
        if: steps.submodule.outputs.latestTag != steps.submodule.outputs.originalTag
        run: |
          Set-StrictMode -Version latest

          $file = $(Get-ChildItem | Where-Object { $_.Name -match '^changelog(\.md|\.txt|)$' } )
          if ("$file" -eq "")
          {
              throw "Couldn't find a changelog"
          }
          elseif ($file -is [Array])
          {
              throw "Multiple changelogs found: $file"
          }
          Write-Host "Found changelog: $file"

          [string[]]$lines = Get-Content $file

          # Make sure that there's an `Unreleased` header
          for ($i = 0; $i -lt $lines.Count; $i++)
          {
              $line = $lines[$i]

              # Skip the "Changelog" header and empty lines at the beginning.
              if ($line -match "changelog" -or $line.Trim().Length -eq 0)
              {
                  continue
              }

              # Next, we expect a header for the current version or "Unreleased".
              if (-not $line.StartsWith("#"))
              {
                  throw "Unexpected changelog line: $line"
              }

              # If it's an existing version instead of "Unreleased".
              if (-not ($line -match "unreleased"))
              {
                  Write-Host "Adding a new '## Unreleased' section"
                  $lines = $lines[0..($i - 1)] + @("## Unreleased", "") + $lines[$i..($lines.Count - 1)]
              }
              break
          }

          # Make sure that there's a `Features` header
          for ($i = 0; $i -lt $lines.Count; $i++)
          {
              $line = $lines[$i]

              # Skip the "Changelog" header and empty lines at the beginning.
              if ($line -match "changelog" -or $line -match "unreleased" -or $line.Trim().Length -eq 0)
              {
                  continue
              }

              # Next, we expect a header
              if (-not $line.StartsWith("#"))
              {
                  throw "Unexpected changelog line: $line"
              }

              # add Features as the first sub-header
              if (-not ($line -match "features"))
              {
                  Write-Host "Adding a new '### Features' section"
                  $lines = $lines[0..($i - 1)] + @("### Features", "", "") + $lines[$i..($lines.Count - 1)]
              }
              break
          }

          # Find the last point in the first `Features` header
          for ($i = 0; $i -lt $lines.Count; $i++)
          {
              $line = $lines[$i]
              if ($line -match "Features")
              {
                  # Find the next header and then go backward until we find a non-empty line
                  for ($i++; $i -lt $lines.Count -and -not $lines[$i].StartsWith("#"); $i++) {}
                  for ($i--; $i -gt 0 -and $lines[$i].Trim().Length -eq 0; $i++) {}
                  break
              }
          }

          $pr = '${{ steps.pr.outputs.number }}'
          $tagAnchor = '${{ steps.submodule.outputs.latestTag }}'.Replace('.', '')
          $entry = @("- Bump ${{ inputs.name }} to ${{ steps.submodule.outputs.latestTagNice }} ([#$pr](https://github.com/getsentry/sentry-unity/pull/$pr))",
              "  - [changelog](${{ steps.submodule.outputs.url }}/blob/${{ steps.submodule.outputs.mainBranch }}/CHANGELOG.md#$tagAnchor)",
              "  - [diff](${{ steps.submodule.outputs.url }}/compare/${{ steps.submodule.outputs.originalTag }}...${{ steps.submodule.outputs.latestTag }})",
              "")

          Write-Host "Adding a changelog entry at line $($i):"
          foreach ($line in $entry) {
              Write-Host $line
          }

          $lines = $lines[0..($i - 2)] + $entry + $lines[$i..($lines.Count - 1)]
          $lines | Out-File $file

      # Now make the PR in its final state. This way we only have one commit and no updates if there are no changes between runs.
      - name: Update the PR
        if: steps.submodule.outputs.latestTag != steps.submodule.outputs.originalTag
        uses: peter-evans/create-pull-request@f22a7da129c901513876a2380e2dae9f8e145330
        with:
          base: ${{ steps.root.outputs.baseBranch }}
          branch: ${{ steps.root.outputs.prBranch }}
          commit-message: 'chore: update ${{ inputs.path }} to ${{ steps.submodule.outputs.latestTag }}'
          author: 'GitHub <noreply@github.com>'
          title: 'chore(deps): update ${{ inputs.name }} to ${{ steps.submodule.outputs.latestTagNice }}'
          body: |
            Bumps ${{ inputs.path }} from ${{ steps.submodule.outputs.originalTag }} to ${{ steps.submodule.outputs.latestTag }}.

            Auto-generated by a submodule dependency updater.
          labels: dependencies
